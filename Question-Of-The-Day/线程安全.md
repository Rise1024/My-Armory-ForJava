- 线程安全
  <br>线程安全三要素：
  <br>1.可见性：假设共享对象最初存储在主内存中。在 CPU 1上运行的线程将共享对象读入它的CPU缓存后修改，但是还没来得及即刷新回主内存，这时其他 CPU 上运行的线程就不会看到共享对象的更改。这样，每个线程都可能以自己的线程结束，就出现了可见性问题
  <br>2.原子性：如果线程 A 将一个共享对象的变量读入到它的 CPU 缓存中。此时，线程 B 执行相同的操作，但是进入不同的 CPU 缓存。现在线程A执行 +1 操作，线程B也这样做。现在该变量增加了两次，在每个 CPU 缓存中一次。如果这些增量是按顺序执行的，则变量结果会是 3，并将原始值 +2 写回主内存。但是，这两个增量是同时执行的，没有适当的同步
  <br>3.顺序性：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测
    - AQS
      <br>AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架
      <br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）
        <br>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
        <br>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
        <br>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
        <br>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。
      -ReentrantLock
       ReentrantLock是一个可重入的同步锁，可以通过设置参数决定使用公平锁和非公平锁，由JDK提供可以通过参数决定公平和非公平
      -Semaphore
        信号量，可以控制并发访问的线程个数；可以很容易的控制某个资源被同时访问的个数；就很像三峡大坝对流量的控制；
      -CountDownLatch
         是一个闭锁，通过计数，来保证线程是否需要一直被阻塞
      -ReentrantReadWriteLock
        读写锁其最核心要求：在没有任何读写锁的时候，才可以取得写入锁；
    - ThreadLocal
      ThreadLocal类主要解决的就是让每个线程绑定⾃⼰的值，可以将 ThreadLocal 类形象的⽐喻成存
      放数据的盒⼦，盒⼦中可以存储每个线程的私有数据。基于ThreadLocalMap存值，key为当前线程，ThreadLocalMap类似HashMap，
      进行元素存取时，要清理遇到的垃圾值，且合并原先紧密相邻的元素
    - synchronized
      synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏
    - volatile
      volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。
      但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。且volatile不能保证原子性
    - Atomic（cas原子类）
      Atomic实现的思想是：每个线程中都会拥有共享变量的一份私有拷贝，
      但由于多个线程都抢着操作共享变量，当前线程的私有拷贝已经不是共享变量的最新值；
      当前线程的私有拷贝只有和共享变量的最新值相等时，才能获得对共享变量的操作权利，这个操作是原子性的；
      当前线程的私有拷贝如何追上共享变量的最新值呢？就是在循环中不停的和共享变量最新值比，
      如果不相等，就把自己更新成最新值，再比，不等再更新，直到自己和最新值相等才获得了对共享变量的操作权；
      这套规则是AtomicInteger设计的，操作其维护的int值的线程遵守之；
    - 线程池
      <br>池化技术的思想主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率
      <br>《阿⾥巴巴Java开发⼿册》中强制线程池不允许使⽤ Executors 去创建，⽽是通过ThreadPoolExecutor的⽅式
      <br> ThreadPoolExecutor 3 个最重要的参数：
      <br>1、 corePoolSize : 核⼼线程数线程数定义了最⼩可以同时运⾏的线程数量。
      <br>2、maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数
      量变为最⼤线程数。
      <br>3、workQueue : 当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到
      的话，新任务就会被存放在队列中。
      <br>4. keepAliveTime :当线程池中的线程数量⼤于 corePoolSize 的时候，如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了keepAliveTime 才会被回收销毁；
      <br>3. threadFactory :executor 线程工厂。







