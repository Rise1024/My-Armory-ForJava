- java只有值传递，无论是基本类型还是引用类型（String 是引用类型，是不可变类）
- 类的加载顺序为：
  1.加载父类中的静态属性和静态代码块
  2.加载子类中的静态属性和静态代码块
  3.加载父类中的普通属性和代码块
  4.加载父类中的构造方法
  5.加载子类中的普通属性和代码块
  6.加载子类中的构造方法<br>
static是最先加载的，因为当class文件被加载进内存开始初始化的时候，被static修饰的变量和代码块即分配进了内存，而其他变量是在对象创建后开始加载的，构造方法是最后加载。

- jvm
  1.虚拟机栈来存储通过栈帧的形式来存储每一个方法，堆来存储所有对象实例和数组。
  2.局部变量存储在栈中，实例变量和静态变量存储在堆中。

- Java 对象的创建过程
  1.类加载检查： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到
这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那
必须先执⾏相应的类加载过程。
  2.分配内存： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类
加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。分
配⽅式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是
否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。
  3.初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象
头），这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这
些字段的数据类型所对应的零值。
  4.设置对象头： 初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实
例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对
象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅
式。
  5.执⾏ init ⽅法： 在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从
Java 程序的视⻆来看，对象创建才刚开始， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀
般来说，执⾏ new 指令之后会接着执⾏ <init> ⽅法，把对象按照程序员的意愿进⾏初始化，这样
⼀个真正可⽤的对象才算完全产⽣出来。

- 堆内存中对象的分配的基本策略?
  1.对象优先在eden区分配
  2.大对象直接进入老年代
  3.长期存活的对象将进入老年代

- 对象的访问定位有哪两种⽅式?
  1. 句柄： 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存
   储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；
  2. 直接指针： 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型
       数据的相关信息，⽽reference 中存储的直接就是对象的地址。
     
- 如何判断对象是否死亡?(两种⽅法)
  1.引⽤计数法
  给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任
  何时候计数器为0的对象就是不可能再被使⽤的。
  2.可达性分析算法
  这个算法的基本思想就是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，
  节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不
  可⽤的。

GC Roots对象
1、虚拟机栈（栈帧中的本地变量表）中引用的对象
2、本地方法栈中JNI（即一般说的Native方法）引用的对象
3、方法区中类静态属性引用的对象
4、方法区中常量引用的对象
  
- 引用
  - 强引用 
    如果一个对象具有强引用，那就类似于必不可少的物品，不会被垃圾回收器回收。
    当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。当对象置为null时才会触发垃圾回收
    Java对于简单的情况, 如方法中的产生的局部对象，是不需要程序员来手动置空,  当调用它的方法执行完毕后, 指向它的引用会被GC回收。
    而复杂一点的情况，比如使用cache,因为cache的对象正是程序运行需要的, 那么只要程序正在运行, cache中的引用就不会被GC，那么随着cache中的引用越来越多, GC无法回收的对象也越来越多, 无法被自动回收，此时就必须有开发者来进行处理回收，显然也违背了java自动回收机制。
  - 软引用
    特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。
    只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。
    软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
    后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象
  - 弱引用
    特点：弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。
    在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
    由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。
    弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，
    Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。