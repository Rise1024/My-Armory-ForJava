- Collection
    - List(有序可重复，包括null)
        - Arraylist ： Object[] 数组 线程不安全
        - Vector ： Object[] 数组 线程安全
        - LinkedList ： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环) 线程不安全
        - CopyOnWriteArrayList :可以看作是线程安全的 ArrayList ，在读多写少的场合性能⾮常好，远远好于Vector  线程安全
        - ConcurrentLinkedQueue :⾼效的并发队列，使⽤链表实现。可以看做⼀个线程安全的LinkedList 线程安全
            1. 数组和链表有什么区别? <br>
              数组会在内存当中开辟一块连续的存储空间,需要指定长度
              数组当中的每一个元素都有索引,查询的话通过索引可以直接定位到
              某一个元素,效率很高,但是进行删除的话,数组会进行移动,
              所以效率很低.<br>
              链表不需要连续的存储单元,链表中的上一个元素通过指针指向
              下一个元素,所以链表结构进行查询的话,头部尾部比较快,
              中间元素查找速度比较慢,但是删除的话,只需要删除前后指针,重新
              建立指针就可以了,所以删除的性能很高.
            2. ArrayList和LinkedList有什么区别？<br>
              ArrayList<br>
               基于动态数组的数据结构<br>
               执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。
               但是如果要在指定位置i插⼊和删除元素的话（ add(int index, E element) 时间复杂度就为 O(n-i)。
               因为在进 ⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作<br>
               占用内存少，每个索引的位置是实际的数据<br>
               效率高，线程不安全<br> 
              LinkedList<br>
               链表结构<br>
              LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O(1)，
              如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊。<br>
               占用内存较多，每个节点中存储的是实际的数据和前后节点的位置<br>
               线程不安全<br>
            3. ArrayList的扩容机制？<br>
                  使用ArrayList()创建ArrayList对象时，不会定义底层数组的长度，当第一次调用add(E e) 方法时，初始化定义底层数组的长度为10，之后调用add(E e)时，
                  如果需要扩容，则调用grow(int minCapacity) 进行扩容,长度为原来的1.5倍。<br>
                  扩容的条件 需要的最小空间大于数组的内存空间<br>
                  最小空间minCapacity的计算：数组内的元素数量加1
                  
    - Set
      - HashSet （⽆序，唯⼀）: HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT
      - LinkedHashSet ： LinkedHashSet 是 HashSet 的⼦类，并且其内部是通过LinkedHashMap来实现的。
      - TreeSet （有序，唯⼀）： 基于二叉树来实现的,可以对元素进行排序(排序规则默认是自然顺序,可以自定义比较器,实现自定义排序)
    - Queue     
      阻塞队列是一种队列，一种可以在多线程环境下使用，并且支持阻塞等待的队列。也就是说，阻塞队列和一般的队列的区别就在于：
      1、多线程环境支持，多个线程可以安全的访问队列
      2、支持生产和消费等待，多个线程之间互相配合，当队列为空的时候，消费线程会阻塞，等待队列不为空；当队列满了的时候，生产线程就会阻塞，直到队列不满
         <br>1.ArrayDeque, （数组双端队列）
         <br>2.PriorityQueue, （优先级队列）
         <br>3.ConcurrentLinkedQueue, （基于链表的并发队列）
         <br>4.DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口）
         <br>5.ArrayBlockingQueue, （基于数组的并发阻塞队列）
         <br>6.LinkedBlockingQueue, （基于链表的FIFO阻塞队列）
         <br>7.LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）
         <br>8.PriorityBlockingQueue, （带优先级的无界阻塞队列）
         <br>9.SynchronousQueue （并发同步阻塞队列）　ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。
- Map
    -  HashMap ： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主
        要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较⼤
        的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓
        度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以
        减少搜索时间
    -  LinkedHashMap ： LinkedHashMap 继承⾃ HashMap ，所以它的底层仍然是基于拉链式散
        列结构即由数组和链表或红⿊树组成。另外， LinkedHashMap 在上⾯结构的基础上，增加了
        ⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，
        实现了访问顺序相关逻辑。
    -  TreeMap ： 红⿊树（⾃平衡的排序⼆叉树）
         1.HashMap的底层实现原理？
         如果哈希表为空，调用resize()创建一个哈希表，如果指定参数hash在表中没有对应的桶，即为没有碰撞，直接将键值对插入到哈希表中即可。
         如果有碰撞，遍历桶，找到key映射的节点,比较桶的第一个元素，如果没有查到相应的键值对，则按照链表添加，
         如果有则判断存储的数据结构是红黑树还是链表，按照各自类型添加键值对，
         当桶中节点数目大于8时，将链表转成红黑树存储，在此之前会有一个判断，桶数组table的长度小于64，不符合转化为红黑树的条件，会进行数组2倍扩容
         
         2.==与 equals 的区别?<br>
         对于基本类型来说，==⽐较的是值是否相等；
         对于引⽤类型来说，==⽐较的是两个引⽤是否指向同⼀个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同⼀个地⽅）；
         对于引⽤类型（包括包装类型）来说，equals 如果没有被重写，对⽐它们的地址是否相等；如果equals()⽅法被重写（例如 String），则⽐较的是地址⾥的内容。
         所以对于对象的比较要重新hashCode()与 equals()的方法，
         3.Hashmap线程不安全的原因？
         尽管在JDK1.8中，进行元素插入时使用的是尾插法，解决了在多线程环境下出现环形链表的情况，
         但是在多线程的情况下仍然不安全，会发生数据覆盖的情况，如果没有hash碰撞则会直接插入元素。
         我们假设线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以线程A、B都会进入第6行代码中，
         （由于没有值，自然检测不到哈希碰撞，所以会直接插入）。
         假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B也判断此处为空，正常执行，从而正常插入数据，然后线程A获取CPU时间片，
         由于之前已经进行了hash碰撞的判断，所以此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。
         所以多线程使用ConcurrentHashMap
         
         4. ConcurrentHashMap 的实现？<br>
            线程安全是使用volatile修饰且自旋CAS操作实现
            volatile保证线程的可见性，同时防止指令的重排序，
            CAS原理 CAS（当前值V，期望值E，新值N）
            如果V=E，则设置N，否则设置失败，重新来一次，其中会有ABA的问题，可以利用version来解决







