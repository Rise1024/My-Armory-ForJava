package com.leetcode.map;

/**
 * @Auther: zds
 * @Date: 2023/02/01/16:41
 * @Description:
 * 数组+链表改成了数组+链表或红黑树；
 * 链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后；
 * 扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小；
 * 在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；
 *
    防止发生 hash 冲突，链表长度过长，将时间复杂度由O(n)降为O(logn);
    因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；
    A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环，

说起循环链表，我就想起一个有趣的问题环形链表问题
这里面就牵涉一个面试中经常问到的问题
1.7hashmap中的链表使用头插法为什么到了1.8使用尾插法
很多人知道的是使用头插法会使链表发生反转，多线程环境下会产生环型链表，产生致命的无限循环
但这肯定不是主要因素
因为Hashmap在多线程下使用本来就是不被允许的
其中最大的原因是在1.8之前因为处理hash冲突的方式是用链表存放数据，使用头插法不需要遍历可以提升效率
但是在 1.8之后当链表长度达到阈值，
就会升级为红黑树
所以哪怕进行尾插法，
遍历次数也是有限的，
效率影响不大。

 */
public class HashMapdemo {

}
